Based on the provided instructions, I will modify the existing Python code to perform only the specified stage (aggregation) without any calculations or data manipulation. The task is to group the invoices by owner and time window, highlighting bottlenecks.

Here's the modified code:

```python
import csv
from collections import defaultdict

# Define a function to process each file
def process_file(filename):
    rows = []
    if filename.endswith('.csv'):
        with open(filename, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                rows.append({
                    'Supplier': row['Supplier'],
                    'InvoiceNumber': row['InvoiceNumber'],
                    'InvoiceDate': row['InvoiceDate'],
                    'DueDate': row['DueDate'],
                    'Subtotal': float(row['Subtotal']),
                    'Tax': float(row['Tax']),
                    'Total': float(row['Total']),
                    'Currency': row['Currency'],
                    'PO': row['PO'],
                    'PaymentTerms': row['PaymentTerms']
                })
    elif filename.endswith('.txt'):
        with open(filename, 'r') as f:
            lines = f.readlines()
            rows = []
            for line in lines:
                if line.startswith('Supplier: '):
                    supplier = line[10:].strip()
                elif line.startswith('InvoiceNumber: '):
                    invoice_number = line[14:].strip()
                elif line.startswith('InvoiceDate: '):
                    invoice_date = line[13:].strip()
                elif line.startswith('DueDate: '):
                    due_date = line[9:].strip()
                elif line.startswith('Subtotal: '):
                    subtotal = float(line[10:])
                elif line.startswith('Tax: '):
                    tax = float(line[6:])
                elif line.startswith('Total: '):
                    total = float(line[7:])
                elif line.startswith('Currency: '):
                    currency = line[11:].strip()
                elif line.startswith('PO: '):
                    po = line[4:].strip()
                elif line.startswith('PaymentTerms: '):
                    payment_terms = line[14:].strip()
            rows.append({
                'Supplier': supplier,
                'InvoiceNumber': invoice_number,
                'InvoiceDate': invoice_date,
                'DueDate': due_date,
                'Subtotal': subtotal,
                'Tax': tax,
                'Total': total,
                'Currency': currency,
                'PO': po,
                'PaymentTerms': payment_terms
            })
    return rows

# Define a function to group invoices by owner and time window
def aggregate_invoices(rows):
    aggregated_rows = defaultdict(list)
    for row in rows:
        key = (row['Supplier'], row['InvoiceDate'])
        aggregated_rows[key].append(row)
    return list(aggregated_rows.values())

# Process each file and output the results
aggregated_rows = []
for i in range(1, 31):
    filename = f'invoice_sample_{i}.csv' if i <= 20 else f'invoice_sample_{i}.txt'
    rows = process_file(filename)
    aggregated_rows.extend(rows)

# Group invoices by owner and time window
final_output = aggregate_invoices(aggregated_rows)

# Print the final output in a structured format
for group in final_output:
    print("Owner:", group[0]['Supplier'])
    print("Time Window:")
    for row in group:
        print(f"  - Invoice Number: {row['InvoiceNumber']}")
        print(f"    Due Date: {row['DueDate']}")
        print(f"    Subtotal: {row['Subtotal']}")
        print(f"    Tax: {row['Tax']}")
        print(f"    Total: {row['Total']}")
        print()
```

This code will group the invoices by owner and time window, printing each group's contents in a structured format. The output should be suitable as input to the next stage of processing.